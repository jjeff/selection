{"version":3,"file":"selection.min.js","sources":["../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/removeElement.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/index.ts","../src/EventEmitter.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {Properties} from 'csstype';\n\nconst unitify = (val: string | number, unit = 'px'): string => {\n    return typeof val === 'number' ? val + unit : val;\n};\n\n/**\n * Add css to a DOM-Element or returns the current\n * value of a property.\n *\n * @param el The Element.\n * @param attr The attribute or a object which holds css key-properties.\n * @param val The value for a single attribute.\n * @returns {*}\n */\nexport function css(\n    {style}: HTMLElement,\n    attr: Partial<Record<keyof Properties, string | number>> | keyof Properties,\n    val?: string | number\n): void {\n    if (typeof attr === 'object') {\n\n        for (const [key, value] of Object.entries(attr)) {\n            style[key as any] = unitify(value as string | number);\n        }\n\n    } else if (val !== undefined) {\n        style[attr as any] = unitify(val);\n    }\n}\n\n\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype Method = 'addEventListener' | 'removeEventListener';\ntype AnyFunction = (...arg: any) => any;\n\nexport type EventBindingArgs = [\n        EventTarget | Array<EventTarget>,\n        string | Array<string>,\n    AnyFunction,\n    Record<string, unknown>?\n];\n\ninterface EventBinding {\n    (\n        elements: EventTarget | Array<EventTarget>,\n        events: string | Array<string>,\n        fn: AnyFunction,\n        options?: Record<string, unknown>\n    ): EventBindingArgs;\n}\n\n/* eslint-disable prefer-rest-params */\nfunction eventListener(method: Method): EventBinding {\n    return (\n        items: EventTarget | Array<EventTarget>,\n        events: string | Array<string>,\n        fn: AnyFunction, options = {}\n    ): EventBindingArgs => {\n\n        // Normalize array\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\n            items = Array.from(items);\n        } else if (!Array.isArray(items)) {\n            items = [items];\n        }\n\n        if (!Array.isArray(events)) {\n            events = [events];\n        }\n\n        for (const el of items) {\n            for (const ev of events) {\n                el[method](ev, fn as EventListener, {capture: false, ...options});\n            }\n        }\n\n        return [items, events, fn, options];\n    };\n}\n\n/**\n * Add event(s) to element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const on = eventListener('addEventListener');\n\n/**\n * Remove event(s) from element(s).\n * @param elements DOM-Elements\n * @param events Event names\n * @param fn Callback\n * @param options Optional options\n * @return Array passed arguments\n */\nexport const off = eventListener('removeEventListener');\n\n/**\n * Simplifies a touch / mouse-event\n * @param evt\n */\nexport const simplifyEvent = (evt: any): {\n    tap: MouseEvent | Touch;\n    x: number;\n    y: number;\n    target: HTMLElement;\n} => {\n    const tap = (evt.touches && evt.touches[0] || evt);\n    return {\n        tap,\n        x: tap.clientX,\n        y: tap.clientY,\n        target: tap.target\n    };\n};\n\n/**\n * Polyfill for safari & firefox for the eventPath event property.\n * @param evt The event object.\n * @return [String] event path.\n */\nexport function eventPath(evt: any): Array<EventTarget> {\n    let path: Array<EventTarget> = evt.path || (evt.composedPath && evt.composedPath());\n    if (path) {\n        return path;\n    }\n\n    let el = evt.target.parentElement;\n    path = [evt.target, el];\n    while (el = el.parentElement) {\n        path.push(el);\n    }\n\n    path.push(document, window);\n    return path;\n}\n\n","export type Intersection = 'center' | 'cover' | 'touch'\n\n/**\n * Check if two DOM-Elements intersects each other.\n * @param a BoundingClientRect of the first element.\n * @param b BoundingClientRect of the second element.\n * @param mode Options are center, cover or touch.\n * @returns {boolean} If both elements intersects each other.\n */\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\n    switch (mode) {\n        case 'center': {\n            const bxc = b.left + b.width / 2;\n            const byc = b.top + b.height / 2;\n\n            return bxc >= a.left &&\n                bxc <= a.right &&\n                byc >= a.top &&\n                byc <= a.bottom;\n        }\n        case 'cover': {\n            return b.left >= a.left &&\n                b.top >= a.top &&\n                b.right <= a.right &&\n                b.bottom <= a.bottom;\n        }\n        case 'touch': {\n            return a.right >= b.left &&\n                a.left <= b.right &&\n                a.bottom >= b.top &&\n                a.top <= b.bottom;\n        }\n        default: {\n            throw new Error(`Unkown intersection mode: ${mode}`);\n        }\n    }\n}\n","/**\n * Removes an element from an Array.\n */\nexport function removeElement<T>(arr: T[], el: T): void {\n    const index = arr.indexOf(el);\n\n    if (~index) {\n        arr.splice(index, 1);\n    }\n}\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\n\n/**\n * Takes a selector (or array of selectors) and returns the matched nodes.\n * @param selector The selector or an Array of selectors.\n * @param doc\n * @returns {Array} Array of DOM-Nodes.\n */\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Array<Element> {\n    const list = !Array.isArray(selector) ? [selector] : selector;\n\n    const nodes = [];\n    for (let i = 0, l = list.length; i < l; i++) {\n        const item = list[i];\n\n        if (typeof item === 'string') {\n            nodes.push(...Array.from(doc.querySelectorAll(item)));\n        } else if (item instanceof HTMLElement) {\n            nodes.push(item);\n        }\n    }\n\n    return nodes;\n}\n","// Determines if the device's primary input supports touch\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\nexport const isTouchDevice = window.matchMedia('(hover: none), (pointer: coarse)').matches;\n","import {css, eventPath, intersects, isTouchDevice, off, on, removeElement, selectAll, SelectAllSelectors, simplifyEvent} from '@utils';\nimport {EventTarget} from './EventEmitter';\nimport {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\n\n// Re-export types\nexport * from './types';\n\n// Some var shorting for better compression and readability\nconst {abs, max, min, ceil} = Math;\n\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\n    public static version = VERSION;\n\n    // Options\n    private readonly _options: SelectionOptions;\n\n    // Selection store\n    private _selection: SelectionStore = {\n        touched: [],\n        stored: [],\n        selected: [],\n        changed: {\n            added: [], // Added elements since last selection\n            removed: [] // Removed elements since last selection\n        }\n    };\n\n    // Area element and clipping element\n    private readonly _area: HTMLElement;\n    private readonly _clippingElement: HTMLElement;\n\n    // Target container (element) and boundary (cached)\n    private _targetElement?: Element;\n    private _targetRect?: DOMRect;\n    private _selectables: Array<Element> = [];\n\n    // Caches the position of the selection-area\n    private readonly _areaRect = new DOMRect();\n\n    // Dynamically constructed area rect\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\n\n    // If a single click is being performed.\n    // It's a single-click until the user dragged the mouse.\n    private _singleClick = true;\n\n    // Is getting set on movement. Varied.\n    private _scrollAvailable = true;\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\n\n    constructor(opt: Partial<SelectionOptions>) {\n        super();\n\n        this._options = Object.assign({\n            class: 'selection-area',\n            document: window.document,\n            intersect: 'touch',\n            startThreshold: 10,\n            singleClick: true,\n            allowTouch: true,\n            overlap: 'invert',\n            selectables: [],\n\n            singleTap: {\n                allow: true,\n                intersect: 'native'\n            },\n\n            scrolling: {\n                speedDivider: 10,\n                manualSpeed: 750\n            },\n\n            startareas: ['html'],\n            boundaries: ['html'],\n            container: 'body'\n        }, opt);\n\n        // Bind locale functions to instance\n        /* eslint-disable @typescript-eslint/no-explicit-any */\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\n            if (typeof (this as any)[key] === 'function') {\n                (this as any)[key] = (this as any)[key].bind(this);\n            }\n        }\n\n        const {document} = this._options;\n        this._area = document.createElement('div');\n        this._clippingElement = document.createElement('div');\n        this._clippingElement.appendChild(this._area);\n\n        // Add class to the area element\n        this._area.classList.add(this._options.class);\n\n        // Apply basic styles to the area element\n        css(this._area, {\n            willChange: 'top, left, bottom, right, width, height',\n            top: 0,\n            left: 0,\n            position: 'fixed'\n        });\n\n        css(this._clippingElement, {\n            overflow: 'hidden',\n            position: 'fixed',\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\n            pointerEvents: 'none',\n            zIndex: '1'\n        });\n\n        this.enable();\n    }\n\n    _bindStartEvents(activate = true): void {\n        const {document, allowTouch} = this._options;\n        const fn = activate ? on : off;\n\n        fn(document, 'mousedown', this._onTapStart);\n        allowTouch && fn(document, 'touchstart', this._onTapStart, {\n            passive: false\n        });\n    }\n\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\n        const {x, y, target} = simplifyEvent(evt);\n        const {_options} = this;\n        const {document} = this._options;\n        const targetBoundingClientRect = target.getBoundingClientRect();\n\n        // Find start-areas and boundaries\n        const startAreas = selectAll(_options.startareas, _options.document);\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\n\n        // Check in which container the user currently acts\n        this._targetElement = resolvedBoundaries.find(el =>\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\n        );\n\n        // Check if area starts in one of the start areas / boundaries\n        const evtpath = eventPath(evt);\n        if (!this._targetElement ||\n            !startAreas.find(el => evtpath.includes(el)) ||\n            !resolvedBoundaries.find(el => evtpath.includes(el))) {\n            return;\n        }\n\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\n            return;\n        }\n\n        // Area rect\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\n\n        // Lock scrolling in target container\n        // Solution to preventing scrolling taken fr\n        const scrollElement = document.scrollingElement || document.body;\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\n\n        // To detect single-click\n        this._singleClick = true;\n        this.clearSelection(false);\n\n        // Add listener\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        on(document, 'scroll', this._onScroll);\n    }\n\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\n        const {intersect} = this._options.singleTap;\n        const spl = simplifyEvent(evt);\n        let target = null;\n\n        if (intersect === 'native') {\n            target = spl.target;\n        } else if (intersect === 'touch') {\n            this.resolveSelectables();\n\n            const {x, y} = spl;\n            target = this._selectables.find(v => {\n                const {right, left, top, bottom} = v.getBoundingClientRect();\n                return x < right && x > left && y < bottom && y > top;\n            });\n        }\n\n        if (!target) {\n            return;\n        }\n\n        /**\n         * Resolve selectables again.\n         * If the user starded in a scrollable area they will be reduced\n         * to the current area. Prevent the exclusion of these if a range-selection\n         * gets performed.\n         */\n        this.resolveSelectables();\n\n        // Traverse dom upwards to check if target is selectable\n        while (!this._selectables.includes(target)) {\n            if (!target.parentElement) {\n                return;\n            }\n\n            target = target.parentElement;\n        }\n\n        // Grab current store first in case it gets resetted\n        const {stored} = this._selection;\n\n        // Emit event and process element\n        this._emitEvent('start', evt);\n        if (evt.shiftKey && stored.length) {\n            const reference = stored[stored.length - 1];\n\n            // Resolve correct range\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\n                [target, reference] : [reference, target];\n\n            const rangeItems = [...this._selectables.filter(el =>\n                (el.compareDocumentPosition(preceding) & 4) &&\n                (el.compareDocumentPosition(following) & 2)\n            ), target, preceding, following];\n\n            this.select(rangeItems);\n        } else if (stored.includes(target) && (stored.length === 1 || evt.ctrlKey)) {\n            this.deselect(target);\n        } else {\n            this.select(target);\n        }\n\n        this._emitEvent('stop', evt);\n    }\n\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\n        const {startThreshold, container, document, allowTouch} = this._options;\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\n        const {x, y} = simplifyEvent(evt);\n\n        // Check pixel threshold\n        const thresholdType = typeof startThreshold;\n        if (\n\n            // Single number\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\n\n            // Different x and y threshold\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\n        ) {\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\n\n            // Make area element visible\n            css(this._area, 'display', 'block');\n\n            // Apppend selection-area to the dom\n            selectAll(container, document)[0].appendChild(this._clippingElement);\n\n            // Now after the threshold is reached resolve all selectables\n            this.resolveSelectables();\n\n            // An action is recognized as single-select until the user performed a mutli-selection\n            this._singleClick = false;\n\n            // Just saving the boundaries of this container for later\n            this._targetRect = this._targetElement!.getBoundingClientRect();\n\n            // Find container and check if it's scrollable\n            this._scrollAvailable =\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\n\n            if (this._scrollAvailable) {\n\n                // Detect mouse scrolling\n                on(document, 'wheel', this._manualScroll, {passive: false});\n\n                /**\n                 * The selection-area will also cover other element which are\n                 * out of the current scrollable parent. So find all elements\n                 * which are in the current scrollable element. Later these are\n                 * the only selectables instead of all.\n                 */\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\n            }\n\n            // Trigger recalc and fire event\n            this._prepareSelectionArea();\n            this._emitEvent('start', evt);\n            this._onTapMove(evt);\n        }\n\n        if (allowTouch && isTouchDevice) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _prepareSelectionArea(): void {\n        const {_clippingElement, _targetElement, _area} = this;\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\n\n        if (this._scrollAvailable) {\n\n            /**\n             * To clip the area, the selection area has a parent\n             * which has exact the same dimensions as the scrollable elemeent.\n             * Now if the area exeeds these boundaries it will be cropped.\n             */\n            css(_clippingElement, {\n                top: tr.top,\n                left: tr.left,\n                width: tr.width,\n                height: tr.height\n            });\n\n            /**\n             * The area element is relative to the clipping element,\n             * but when this is moved or transformed we need to correct\n             * the positions via a negative margin.\n             */\n            css(_area, {\n                marginTop: -tr.top,\n                marginLeft: -tr.left\n            });\n        } else {\n\n            /**\n             * Reset margin and clipping element dimensions.\n             */\n            css(_clippingElement, {\n                top: 0,\n                left: 0,\n                width: '100%',\n                height: '100%'\n            });\n\n            css(_area, {\n                marginTop: 0,\n                marginLeft: 0\n            });\n        }\n    }\n\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\n        const {x, y} = simplifyEvent(evt);\n        const {_scrollSpeed, _areaLocation, _options} = this;\n        const {allowTouch} = _options;\n        const {speedDivider} = _options.scrolling;\n        const scon = this._targetElement as Element;\n\n        _areaLocation.x2 = x;\n        _areaLocation.y2 = y;\n\n        if (this._scrollAvailable && (_scrollSpeed.y || _scrollSpeed.x)) {\n            const scroll = () => {\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\n                    return;\n                }\n\n                /**\n                 * If the value exeeds the scrollable area it will\n                 * be set to the max / min value. So change only\n                 */\n                const {scrollTop, scrollLeft} = scon;\n\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\n                if (_scrollSpeed.y) {\n                    scon.scrollTop += ceil(_scrollSpeed.y / speedDivider);\n                    _areaLocation.y1 -= scon.scrollTop - scrollTop;\n                }\n\n                if (_scrollSpeed.x) {\n                    scon.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\n                    _areaLocation.x1 -= scon.scrollLeft - scrollLeft;\n                }\n\n                /**\n                 * We changed the start coordinates -> redraw the selectiona area\n                 * We changed the dimensions of the area element -> re-calc selected elements\n                 * The selected elements array has been changed -> fire event\n                 */\n                this._recalculateSelectionAreaRect();\n                this._updateElementSelection();\n                this._emitEvent('move', evt);\n                this._redrawSelectionArea();\n\n                // Keep scrolling even if the user stops to move his pointer\n                requestAnimationFrame(scroll);\n            };\n\n            // Continous scrolling\n            requestAnimationFrame(scroll);\n        } else {\n\n            /**\n             * Perform redraw only if scrolling is not active.\n             * If scrolling is active this area is getting re-dragwed by the\n             * anonymized scroll function.\n             */\n            this._recalculateSelectionAreaRect();\n            this._updateElementSelection();\n            this._emitEvent('move', evt);\n            this._redrawSelectionArea();\n        }\n\n        if (allowTouch && isTouchDevice) {\n            evt.preventDefault(); // Prevent swipe-down refresh\n        }\n    }\n\n    _onScroll(): void {\n        const {_scrollDelta, _options: {document}} = this;\n\n        // Resolve scrolling offsets\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\n\n        // Adjust area start location\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\n        _scrollDelta.x = scrollLeft;\n        _scrollDelta.y = scrollTop;\n\n        // The area needs to be resetted as the target-container has changed in its position\n        this._prepareSelectionArea();\n        this._recalculateSelectionAreaRect();\n        this._updateElementSelection();\n        this._emitEvent('move', null);\n        this._redrawSelectionArea();\n    }\n\n    _manualScroll(evt: ScrollEvent): void {\n        const {manualSpeed} = this._options.scrolling;\n\n        // Consistent scrolling speed on all browsers\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\n        this._scrollSpeed.y += deltaY * manualSpeed;\n        this._scrollSpeed.x += deltaX * manualSpeed;\n        this._onTapMove(evt);\n\n        // Prevent defaul scrolling behaviour, eg. page scrolling\n        evt.preventDefault();\n    }\n\n    _recalculateSelectionAreaRect(): void {\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _targetRect} = this;\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\n        const brect = _targetRect as DOMRect;\n        let {x1, y1, x2, y2} = _areaLocation;\n\n        if (x2 < brect.left) {\n            _scrollSpeed.x = scrollLeft ? -abs(brect.left - x2) : 0;\n            x2 = brect.left;\n        } else if (x2 > brect.right) {\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x2) : 0;\n            x2 = brect.right;\n        } else {\n            _scrollSpeed.x = 0;\n        }\n\n        if (y2 < brect.top) {\n            _scrollSpeed.y = scrollTop ? -abs(brect.top - y2) : 0;\n            y2 = brect.top;\n        } else if (y2 > brect.bottom) {\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y2) : 0;\n            y2 = brect.bottom;\n        } else {\n            _scrollSpeed.y = 0;\n        }\n\n        const x3 = min(x1, x2);\n        const y3 = min(y1, y2);\n        const x4 = max(x1, x2);\n        const y4 = max(y1, y2);\n\n        _areaRect.x = x3;\n        _areaRect.y = y3;\n        _areaRect.width = x4 - x3;\n        _areaRect.height = y4 - y3;\n    }\n\n    _redrawSelectionArea(): void {\n        const {x, y, width, height} = this._areaRect;\n        const {style} = this._area;\n\n        // Using transform will make the area's borders look blurry\n        style.left = `${x}px`;\n        style.top = `${y}px`;\n        style.width = `${width}px`;\n        style.height = `${height}px`;\n    }\n\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\n        const {document, singleTap} = this._options;\n        const {_singleClick} = this;\n\n        // Remove event handlers\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\n        off(document, 'scroll', this._onScroll);\n\n        if (evt && _singleClick && singleTap.allow) {\n            this._onSingleTap(evt);\n        } else if (!_singleClick && !silent) {\n            this._updateElementSelection();\n            this._emitEvent('stop', evt);\n        }\n\n        // Reset scroll speed\n        this._scrollSpeed.x = 0;\n        this._scrollSpeed.y = 0;\n\n        // Unbind mouse scrolling listener\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\n\n        // Remove selection-area from dom\n        this._clippingElement.remove();\n\n        // Hide selection area\n        css(this._area, 'display', 'none');\n    }\n\n    _updateElementSelection(): void {\n        const {_selectables, _options, _selection, _areaRect} = this;\n        const {stored, selected, touched} = _selection;\n        const {intersect, overlap} = _options;\n\n        // Update\n        const newlyTouched = [];\n        const added = [];\n        const removed = [];\n\n        // Itreate over the selectable elements\n        for (let i = 0; i < _selectables.length; i++) {\n            const node = _selectables[i];\n\n            // Check if area intersects element\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\n\n                // Check if the element wasn't present in the last selection.\n                if (!selected.includes(node)) {\n\n                    // Check if user wants to invert the selection for already selected elements\n                    if (overlap === 'invert' && stored.includes(node)) {\n                        removed.push(node);\n                        continue;\n                    } else {\n                        added.push(node);\n                    }\n                } else if (stored.includes(node) && !touched.includes(node)) {\n                    touched.push(node);\n                }\n\n                newlyTouched.push(node);\n            }\n        }\n\n        // Re-select elements which were previously stored\n        if (overlap === 'invert') {\n            added.push(...stored.filter(v => !selected.includes(v)));\n        }\n\n        // Check which elements where removed since last selection\n        for (let i = 0; i < selected.length; i++) {\n            const node = selected[i];\n\n            if (!newlyTouched.includes(node) && !(\n\n                // Check if user wants to keep previously selected elements, e.g.\n                // not make them part of the current selection as soon as they're touched.\n                overlap === 'keep' && stored.includes(node)\n            )) {\n                removed.push(node);\n            }\n        }\n\n        // Save\n        _selection.selected = newlyTouched;\n        _selection.changed = {added, removed};\n    }\n\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\n        return this.emit(name, {\n            event: evt,\n            store: this._selection\n        });\n    }\n\n    /**\n     * Manually triggers the start of a selection\n     * @param evt A MouseEvent / TouchEvent -like object\n     * @param silent If beforestart should be fired,\n     */\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\n        this._onTapStart(evt, silent);\n    }\n\n    /**\n     * Can be used if during a selection elements have been added.\n     * Will update everything which can be selected.\n     */\n    resolveSelectables(): void {\n\n        // Resolve selectors\n        this._selectables = selectAll(this._options.selectables, this._options.document);\n    }\n\n    /**\n     * Saves the current selection for the next selecion.\n     * Allows multiple selections.\n     */\n    keepSelection(): void {\n        const {_options, _selection} = this;\n        const {selected, changed, touched, stored} = _selection;\n\n        // Newly added elements\n        const addedElements = selected.filter(el => !stored.includes(el));\n\n        switch (_options.overlap) {\n            case 'drop': {\n                _selection.stored = addedElements.concat(\n\n                    // Elements not touched\n                    stored.filter(el => !touched.includes(el))\n                );\n                break;\n            }\n            case 'invert': {\n                _selection.stored = addedElements.concat(\n\n                    // Elements not removed from selection\n                    stored.filter(el => !changed.removed.includes(el))\n                );\n                break;\n            }\n            case 'keep': {\n                _selection.stored = stored.concat(\n\n                    // Newly added\n                    selected.filter(el => !stored.includes(el))\n                );\n                break;\n            }\n        }\n    }\n\n    /**\n     * Clear the elements which where saved by 'keepSelection()'.\n     * @param store If the store should also get cleared\n     */\n    clearSelection(store = true): void {\n        this._selection = {\n            stored: store ? [] : this._selection.stored,\n            selected: [],\n            touched: [],\n            changed: {\n                added: [],\n                removed: []\n            }\n        };\n    }\n\n    /**\n     * @returns {Array} Selected elements\n     */\n    getSelection(): Array<Element> {\n        return this._selection.stored;\n    }\n\n    /**\n     * @returns {HTMLElement} The selection area element\n     */\n    getSelectionArea(): HTMLElement {\n        return this._area;\n    }\n\n    /**\n     * Cancel the current selection process.\n     * @param keepEvent {boolean} true to fire the onStop listener after cancel.\n     */\n    cancel(keepEvent = false): void {\n        this._onTapStop(null, !keepEvent);\n    }\n\n    /**\n     * Unbinds all events and removes the area-element.\n     */\n    destroy(): void {\n        this.cancel();\n        this.disable();\n        this._clippingElement.remove();\n        super.unbindAllListeners();\n    }\n\n    /**\n     * Disable the selection functinality.\n     */\n    /* eslint-disable no-invalid-this */\n    disable = this._bindStartEvents.bind(this, false);\n\n    /**\n     * Disable the selection functinality.\n     */\n    /* eslint-disable no-invalid-this */\n    enable = this._bindStartEvents;\n\n    /**\n     * Adds elements to the selection\n     * @param query - CSS Query, can be an array of queries\n     * @param quiet - If this should not trigger the move event\n     */\n    select(query: SelectAllSelectors, quiet = false): Array<Element> {\n        const {changed, selected, stored} = this._selection;\n        const elements = selectAll(query, this._options.document).filter(el =>\n            !selected.includes(el) &&\n            !stored.includes(el)\n        );\n\n        // Update stores\n        selected.push(...elements);\n        changed.added.push(...elements);\n\n        !quiet && this._emitEvent('move', null);\n        return elements;\n    }\n\n    /**\n     * Removes an particular element from the selection.\n     * @param el - Element to remove.\n     * @param quiet - If this should not trigger the move event\n     * @returns boolean - true if the element was successfully removed\n     */\n    deselect(el: Element, quiet = false): boolean {\n        const {selected, stored, changed} = this._selection;\n\n        if (\n            selected.includes(el) ||\n            stored.includes(el)\n        ) {\n            changed.removed.push(el);\n            removeElement(stored, el);\n            removeElement(selected, el);\n\n            // Fire event\n            !quiet && this._emitEvent('move', null);\n            return true;\n        }\n\n        return false;\n    }\n}\n","\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype AnyFunction = (...args: any[]) => any;\ntype EventMap = Record<string, AnyFunction>;\n\nexport class EventTarget<Events extends EventMap> {\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\n\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        const set = this._listeners.get(event) || new Set();\n        this._listeners.set(event, set);\n        set.add(cb as AnyFunction);\n        return this;\n    }\n\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\n        this._listeners.get(event)?.delete(cb as AnyFunction);\n        return this;\n    }\n\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\n        let ok = true;\n        for (const cb of (this._listeners.get(event) || [])) {\n            ok = (cb(...data) !== false) && ok;\n        }\n\n        return ok;\n    }\n\n    public unbindAllListeners(): void {\n        this._listeners.clear();\n    }\n\n    // Let's also support on, off and emit like node\n    /* eslint-disable no-invalid-this */\n    public on = this.addEventListener;\n    public off = this.removeEventListener;\n    public emit = this.dispatchEvent;\n}\n"],"names":["unitify","val","unit","css","style","attr","key","value","Object","entries","undefined","eventListener","method","items","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","el","ev","capture","on","off","simplifyEvent","evt","tap","touches","x","clientX","y","clientY","target","eventPath","path","composedPath","parentElement","push","document","window","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","Error","removeElement","arr","index","indexOf","splice","selectAll","selector","doc","list","nodes","i","l","length","item","querySelectorAll","HTMLElement","isTouchDevice","matchMedia","matches","abs","max","min","ceil","Math","SelectionArea","[object Object]","this","Map","addEventListener","removeEventListener","dispatchEvent","event","cb","set","_listeners","get","Set","add","delete","data","ok","clear","opt","super","touched","stored","selected","changed","added","removed","DOMRect","y1","x2","y2","x1","_bindStartEvents","bind","_options","assign","class","intersect","startThreshold","singleClick","allowTouch","overlap","selectables","singleTap","allow","scrolling","speedDivider","manualSpeed","startareas","boundaries","container","getOwnPropertyNames","getPrototypeOf","_area","createElement","_clippingElement","appendChild","classList","willChange","position","overflow","transform","pointerEvents","zIndex","enable","activate","_onTapStart","passive","silent","_","targetBoundingClientRect","getBoundingClientRect","startAreas","resolvedBoundaries","_targetElement","find","evtpath","includes","_emitEvent","_areaLocation","scrollElement","scrollingElement","body","_scrollDelta","scrollLeft","scrollTop","_singleClick","clearSelection","_delayedTapMove","_onTapStop","_onScroll","spl","resolveSelectables","_selectables","v","_selection","shiftKey","reference","preceding","following","compareDocumentPosition","rangeItems","filter","select","ctrlKey","deselect","thresholdType","_onTapMove","_targetRect","_scrollAvailable","scrollHeight","clientHeight","scrollWidth","clientWidth","_manualScroll","s","contains","_prepareSelectionArea","preventDefault","T","L","S","tr","marginTop","marginLeft","m","_scrollSpeed","scon","scroll","_recalculateSelectionAreaRect","_updateElementSelection","_redrawSelectionArea","requestAnimationFrame","deltaY","deltaX","h","_areaRect","C","brect","x3","y3","x4","y4","u","_onSingleTap","remove","o","newlyTouched","node","name","emit","store","addedElements","concat","keepEvent","cancel","disable","unbindAllListeners","query","quiet","elements"],"mappings":"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"}